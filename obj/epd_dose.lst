C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE epd_dose
OBJECT MODULE PLACED IN .\obj\epd_dose.obj
COMPILER INVOKED BY: D:\KeilMDK\C251\BIN\C251.EXE Hardware\App\epd_dose.c XSMALL INTR2 BROWSE INCDIR(.\Hardware\Usart;.\
                    -Hardware\LED;.\Hardware\TIM;.\Hardware\Eeprom;.\ModBus;.\MwPro;.\Hardware\App;.\USER) DEBUG PRINT(.\obj\epd_dose.lst) OB
                    -JECT(.\obj\epd_dose.obj) 

stmt  level    source

    1          #include "main.h"
    2          #ifdef USE_EPD_DOSE
    3          
    4          #include "epd_dose.h"
    5          #include "PDoseRateCalc.h"
    6          
    7          DWORD PluseCnt = 0;
    8          float fAverCPS=0;
    9          
   10          static float LDtoHDBuf[3];
   11          static BYTE  ldtohdidx = 0;
   12          //char beep_increase_on_flag=0;//是否有累计计量增长报警
   13          #define CPS_500ms_Threshold (3000)
   14          #define CPS_1000ms_Threshold (60000)
   15          //BOOL bGetPkuPer500ms = false;
   16          
   17          //extern float CalcAlpha(unsigned long realCPS, float oldCPS);
   18          extern DWORD Cps;
   19          extern float CpsHis;
   20          
   21          //为提高运算校率，校验采用查表法：
   22          //--------------------------------------------------------
   23          //DESCRIPTION:RTU CRC校验的高位字节表
   24          //--------------------------------------------------------
   25          const u8 auchCRCHi[] = {    
   26          0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
   27          0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
   28          0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
   29          0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
   30          0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
   31          0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
   32          0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
   33          0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
   34          0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
   35          0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
   36          0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
   37          0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
   38          0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
   39          0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
   40          0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
   41          0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
   42          };
   43          
   44          //--------------------------------------------------------
   45          //DESCRIPTION:RTU CRC校验的低位字节表
   46          //--------------------------------------------------------
   47          const u8 auchCRCLo[]={
   48          0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 
   49          0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 
   50          0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 
   51          0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10, 
   52          0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 
   53          0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 
   54          0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 
   55          0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 
   56          0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 
   57          0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 2   

   58          0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 
   59          0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 
   60          0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 
   61          0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 
   62          0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
   63          0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
   64          };
   65          
   66          //校验函数:
   67          u16 CRC16(u8 *PuchMsg, u16 usDataLen)
   68          {
   69   1          u8  uchCRCHi = 0xFF;       //high byte of CRC initialized
   70   1          u8  uchCRCLo = 0xFF;       //low byte of CRC initialized
   71   1          u32 uIndex;                //will index into CRC lookup table
   72   1      
   73   1          while (usDataLen--)
   74   1          {
   75   2              //calculate the CRC
   76   2              uIndex=uchCRCHi^(unsigned char)(*PuchMsg++);
   77   2              uchCRCHi=uchCRCLo^auchCRCHi[uIndex];
   78   2              uchCRCLo=auchCRCLo[uIndex];
   79   2          }
   80   1          return(uchCRCHi <<8|uchCRCLo);
   81   1      }
   82          
   83          
   84          int QEpdParamInit(QEpd * me)
   85          {
   86   1          struct _QEpdParaInfo *pParaInfo;
   87   1          struct _QEpdBaseConfig *pBaseConfig;
   88   1          struct _QEpdDoseFactor *pDoseFactor;
   89   1          //u16 checkSum;
   90   1          //me->RecvSize = sizeof(QEpdFactoryInfo);        //厂家参数,只读,不允许更改
   91   1          //me->RecvSize = sizeof(QEpdAssignInfo);            //设备分配信息,40Bytes
   92   1          //me->RecvSize = sizeof(QEpdStatusInfo);            //设备状态信息,20Bytes
   93   1          me->RecvSize = sizeof(QEpdBaseConfig);            //设备配置信息,32Bytes
   94   1          me->RecvSize = sizeof(QEpdDoseFactor);        //拟合参数信息,68Bytes = 16x4 + 1 + 3(保留)
   95   1          
   96   1          me->RecvSize = sizeof(struct _QEpdParaInfo);    
   97   1          
   98   1          me->byVariWin = 120;
   99   1          me->updateBatCnt = 0;
  100   1          me->timerCPSCnt = 0;
  101   1          me->idxFilterCPS = 0;
  102   1        //  MSP430XX_FLASH_Erase(QEPD_PARAM_FLASH_BASE_ADDR);
  103   1          //同步数据到内存空间
  104   1          //MSP430XX_FLASH_Read(QEPD_PARAM_FLASH_BASE_ADDR, (void *)&me->EpdPara, sizeof(struct _QEpdParaInfo))
             -;
  105   1          //MSP430XX_FLASH_Read(QEPD_PARAM_FLASH_BASE_ADDR + sizeof(struct _QEpdParaInfo), (void *)&checkSum, 2
             -);
  106   1          pParaInfo= (struct _QEpdParaInfo *)&me->EpdPara;
  107   1          //if((pParaInfo->dwSignature!=0x00103011)||(checkSum!=CRC16((u8 *)pParaInfo, sizeof(struct _QEpdParaI
             -nfo)))) 
  108   1          {
  109   2              //默认值
  110   2              pBaseConfig = (struct _QEpdBaseConfig *)&(me->EpdPara.baseConfig);
  111   2              pDoseFactor = (struct _QEpdDoseFactor *)&(me->EpdPara.tDoseFactor);
  112   2              //struct _QLocalTime     *pLocalTime  = (struct _QLocalTime *)&pBaseConfig->AdjustTime;
  113   2              //struct _QEpdStatusInfo *pStatusInfo = (struct _QEpdStatusInfo *)&me->EpdPara.statusInfo;
  114   2              
  115   2              memset((void *)me,0x00,sizeof *me);
  116   2              me->byVariWin           = 120;
  117   2              me->fDoseSumx                 = 0.0f;
  118   2              //pStatusInfo->iStorageUsed    = 0x0;
  119   2              //pStatusInfo->iStorageMax     = 4096;
  120   2              
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 3   

  121   2              pParaInfo->dwSignature       = 0x00103011;
  122   2              //pParaInfo->dwDeviceNo        = 0x0b59fbf1;//0x88991234;
  123   2              //pParaInfo->DoseNum.tdwDeviceNo.ver = 12;
  124   2              //pParaInfo->DoseNum.tdwDeviceNo.unit = 5;
  125   2              //pParaInfo->DoseNum.tdwDeviceNo.MainID = 654321;
  126   2              //pBaseConfig->iDoseSumxMeddle = 3000;
  127   2              //pBaseConfig->iDoseRateMeddle = 3000;
  128   2              
  129   2              //pBaseConfig->iUsedTimeAlarm = 2;//2分钟时间报警
  130   2                
  131   2              //pBaseConfig->iDoseSumxAlarm = 4000;
  132   2              //pBaseConfig->iDoseRateAlarm = 4000;
  133   2              pBaseConfig->iScaleFactor   = 1.0f;
  134   2              //pBaseConfig->ucRunningMode   = 0x00;
  135   2              //pBaseConfig->ucRunningMode  |= QEPD_PARAM_ASSIGNED_BIT;//分配
  136   2              //pBaseConfig->ucRunningMode  |= QEPD_PARAM_WORKMODE_BIT;//手动模式
  137   2              //pBaseConfig->ucRunningMode  |= QEPD_PARAM_ACTIVE_BIT;//（激活）
  138   2              //pBaseConfig->ucRunningMode  |= QEPD_PARAM_ENERYUSED_BIT;//省电模式
  139   2              
  140   2              //pBaseConfig->ucDoseIncreaseAlarm = 3;//剂量增长1uSv报警
  141   2      
  142   2              //pBaseConfig->ucModeSetting   = 0x00;
  143   2              //pBaseConfig->ucModeSetting  |= QEPD_PARAM_CLEARALARM_BIT;
  144   2              //pBaseConfig->ucModeSetting  |= QEPD_PARAM_INTER_SAVE;
  145   2              //pBaseConfig->ucModeSetting  &= QEPD_PARAM_STORAGE_INTERVAL_MASK;
  146   2              //pBaseConfig->ucModeSetting  |= storageInterval_15Sec*QEPD_PARAM_STORAGE_INTERVAL;
  147   2      
  148   2              //pBaseConfig->ucModeSetting  &= QEPD_PARAM_BACKLIGHT_MODE_MASK;
  149   2              //pBaseConfig->ucModeSetting  |= backLightMode_5sec*QEPD_PARAM_BACKLIGHT_MODE;
  150   2              
  151   2              //pBaseConfig->ucDisplayMode  = 0x00;
  152   2              //pBaseConfig->ucDisplayMode  &= QEPD_PARAM_DISPLAY_UNIT_MASK;
  153   2              //pBaseConfig->ucDisplayMode  |= dispUnit_usv*QEPD_PARAM_DISPLAY_UNIT;
  154   2              
  155   2              pDoseFactor->experimentmode = 0;    
  156   2      //        pDoseFactor->lowfactor[0]= 1;
  157   2      //        pDoseFactor->lowfactor[1]= 1;
  158   2      //        pDoseFactor->lowfactor[2]= 1;
  159   2      //        pDoseFactor->lowfactor[3]= 1;
  160   2      //        pDoseFactor->lowfactor[4]= 1;
  161   2      //        pDoseFactor->lowfactor[5]= 1;
  162   2      //        pDoseFactor->lowfactor[6]= 1;
  163   2      //        pDoseFactor->lowfactor[7]= 1;
  164   2      //        pDoseFactor->lowfactor[8]= 1;
  165   2      //        pDoseFactor->lowfactor[9]= 1;
  166   2      //        pDoseFactor->lowfactor[10]= 1;
  167   2      //        pDoseFactor->lowfactor[11]= 1;
  168   2      //        pDoseFactor->lowfactor[12]= 1;
  169   2      //        pDoseFactor->lowfactor[13]= 1;
  170   2      //        pDoseFactor->lowfactor[14]= 1;
  171   2      //        pDoseFactor->lowfactor[15]= 1;
  172   2              
  173   2              /*
  174   2              pDoseFactor->midfactor0= 4.175559983;
  175   2              pDoseFactor->midfactor1= 13.59064852;
  176   2              pDoseFactor->midfactor2= 0.5482365533e-3;
  177   2              pDoseFactor->midfactor3= -0.1990246458e-6;
  178   2      
  179   2              pDoseFactor->highfactor0= 971.2739047;
  180   2              pDoseFactor->highfactor1= 12.99644062;
  181   2              pDoseFactor->highfactor2= 0.1530853217e-3;
  182   2              pDoseFactor->highfactor3= 0.1215235629e-8;
  183   2      
  184   2              pDoseFactor->highestfactor0=0;
  185   2              pDoseFactor->highestfactor1=0;
  186   2              pDoseFactor->highestfactor2=0;
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 4   

  187   2              pDoseFactor->highestfactor3=0;*/            
  188   2              //MSP430XX_RTC_GetTime(pLocalTime);
  189   2              //checkSum = CRC16((u8 *)pParaInfo, sizeof(struct _QEpdParaInfo));
  190   2              //QEpdParamSaveAll(me);
  191   2          }
  192   1          me->fDoseRate      = me->EpdPara.statusInfo.iMaxDoseRate;
  193   1          me->fDoseSumx    = me->EpdPara.statusInfo.iLastDoseSum;
  194   1          me->fDoseSumIncrease = me->EpdPara.statusInfo.iLastDoseSum;
  195   1          //QEpdParamUpdateSaveTime(me);
  196   1          return true;
  197   1      }
  198          
  199          
  200          
  201          
  202          
  203          #ifdef DEBUG
               
               const float TestCPSBuf[]={0,3,0,1,2,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,2,0,0,1,1,0,1,1
             -,2,1,0,0,1,1,0,0,0,1,1,1,2,0,1,0,0,0,1,1,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,1,1,2,0,0,0
             -,0,0,0,1}; //4us
               
               float GetCPS()
               {
                   int  iCPS= 0;
                   u32 cps = 0;
                   cps = TestCPSBuf[iCPS];
                   if (++iCPS >= (sizeof(TestCPSBuf) / sizeof (TestCPSBuf[0])))
                   {
                        iCPS = 0;
                   }
                   return (float)cps;
               }
               #endif
  219          
  220          
  221          #if 0
               
               
               unsigned long PreCPS = 0;
               void QEpdDoseRateUpdate(QEpd *me)
               {
                   //unsigned short ir;
                   static float SumCPS=0,AverCPS=0;
                   
                   static int i=0,k=0;
                   static int /*iMaxCnt = -1,*/ iMinCnt = -1;
                   static int DoubtCnt=0;
                   static float fTmp = 0;
                   static float Max = 0;      
               
                   iMinCnt = -1;
                   SumCPS=0;
                   AverCPS=0;
                   i=0;
                   k=0;
                   //fAverCPS = 0;
                   DoubtCnt=0;    
                   fTmp = 0;   
                   Max = 0;      
                   
                   #if 0
                       if (me->bGetPkuPer500ms && (PluseCnt < CPS_1000ms_Threshold))
                       {
                           me->bGetPkuPer500ms = 0;
                       }
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 5   

                       // deta CPS_500ms_Threshold 或者邋CPS 大于CPS_1000ms_Threshold，切换到500ms
                       if ( ((PluseCnt > PreCPS) && (PluseCnt - PreCPS) > CPS_500ms_Threshold) || PluseCnt > CPS_1000ms_
             -Threshold )
                       {
                           me->bGetPkuPer500ms = 1;
                       }
                       
                       PreCPS = PluseCnt;
                      me->cpsDoseCount = PluseCnt;
                      LockCritcialSection();   
                      PluseCnt=0;
                      UnLockCriticalSection();
                   #else
                     // me->cpsDoseCount = GetCPS();
                      //PluseCnt = Cps;
                      me->cpsDoseCount = SysParam.s_DoseRate.Cps1;//Cps; // PluseCnt;
                      //LockCritcialSection();   
                      //PluseCnt=0;
                      //UnLockCriticalSection();
                   #endif
                      me->EpdPara.statusInfo.iUsedTime++;
                      me->sumDoseCount += me->cpsDoseCount; 
                      if(++me->timerCPSCnt<=30)
                       {
                         me->cpsDosePerCnt += me->cpsDoseCount;
                       }
                      else if(me->timerCPSCnt>30)
                       {
                         me->cpsDosePerCnt=0; 
                         me->timerCPSCnt=0;
                       }
                   #if 1
                        if (me->byDoseRateMode == LOW_DOSE_RATE_MODE)
                        {
               
                            if (me->cpsDoseCount >= 1)
                            {
                                if (me->idxFilterCPS == 0)
                                {
                                   void *pbuf = (void *)me->affilterCPSBuf;
                                    memset(pbuf, 0, sizeof(me->affilterCPSBuf));
                                    me->idxFilterCPS = 0;
                                }
                                me->affilterCPSBuf[me->idxFilterCPS ] = me->cpsDoseCount;
                                me->idxFilterCPS++;
                            }
               
                            if (me->cpsDoseCount < 1)
                            {
                                 if (me->idxFilterCPS) //检查滤波BUF里面有值
                                 {
                                     for (i = 0; i < me->idxFilterCPS; i++)
                                     {
                                          if (me->affilterCPSBuf[i] > 7)
                                          {
                                               /* affilterCPSBuf 里面的计数可能是噪声引起的退出 */
                                               break;
                                          }
                                      }
                                          
                                      memcpy((void *)me->afCPSBuf, (void *)(me->afCPSBuf + me->idxFilterCPS), 
                                             (FIRST_CPS_MEASURE_TIME - me->idxFilterCPS) * sizeof(me->afCPSBuf[0]));    
             -                       
                         
                              
                                      for (k = 0; k < me->idxFilterCPS ; k++)
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 6   

                                      {
                                          if ( i == me->idxFilterCPS)
                                          {                                   
                                               me->afCPSBuf[FIRST_CPS_MEASURE_TIME - me->idxFilterCPS  + k] = me->affilt
             -erCPSBuf[k];
                                          }
                                          else
                                          {   
                                                /* affilterCPSBuf 噪声引起的计数,afCPSBuf 里面计数用0 */
                                               me->afCPSBuf[FIRST_CPS_MEASURE_TIME - me->idxFilterCPS  + k] = 0; 
                                          }
                                      }
                   
                                              
                                      if(me->nCPSBuf < FIRST_CPS_MEASURE_TIME)
                                      {
                                           if ((me->nCPSBuf = me->nCPSBuf + me->idxFilterCPS) > FIRST_CPS_MEASURE_TIME)
                                           {
                                                me->nCPSBuf = FIRST_CPS_MEASURE_TIME;
                                           }
                                      }     
                                       me->idxFilterCPS = 0;
                                 }
               
                                     
                                 for(i=0;i<(FIRST_CPS_MEASURE_TIME-1);i++)
                                 {
                                      me->afCPSBuf[i] = me->afCPSBuf[i+1];
                                 }
                                 me->afCPSBuf[i]=me->cpsDoseCount;    
                                 if(me->nCPSBuf<FIRST_CPS_MEASURE_TIME)
                                 {
                                      me->nCPSBuf++; 
                                 }
                                     
                            }
                            else
                            {
                                 if(me->idxFilterCPS >= sizeof(me->affilterCPSBuf) / sizeof(me->affilterCPSBuf[0]))
                                 {
                                         memcpy((void *)me->afCPSBuf, (void *)(me->afCPSBuf + me->idxFilterCPS), 
                                                (FIRST_CPS_MEASURE_TIME - me->idxFilterCPS) * sizeof me->afCPSBuf[0]);
                                         
                                         for (k = 0; k < me->idxFilterCPS ; k++)
                                         {                                      
                                              me->afCPSBuf[FIRST_CPS_MEASURE_TIME - me->idxFilterCPS  + k] = me->affilte
             -rCPSBuf[k];
                                         }
               
                                         
                                         if(me->nCPSBuf < FIRST_CPS_MEASURE_TIME)
                                         {
                                              if ((me->nCPSBuf = me->nCPSBuf + me->idxFilterCPS) > FIRST_CPS_MEASURE_TIM
             -E)
                                              {
                                                   me->nCPSBuf = FIRST_CPS_MEASURE_TIME;
                                              }
                                         }     
                                         me->idxFilterCPS = 0;
                                   }
                            }
               
               
               
                            SumCPS = 0;
                            for( i = 0; i < 10; i++)
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 7   

                            {
                                SumCPS += me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 10 + i]; 
                            }
                            AverCPS = SumCPS / 10;
               
                            if (AverCPS >= 1.2)  //大概17us
                            {
                                 DoubtCnt++;
                            }
                            else
                            {
                                DoubtCnt = 0;
                            }
               
               
               
                           if (me->afCPSBuf[FIRST_CPS_MEASURE_TIME- 1] >= MIDDLE_DOSE_RATE_THRE 
                               && me->afCPSBuf[FIRST_CPS_MEASURE_TIME- 2] >= MIDDLE_DOSE_RATE_THRE)
                           {
                               DoubtCnt = 0;
                               me->byDoseRateMode = HIGH_DOSE_RATE_MODE;
                               me->byLowDRCPSBufThre = 1;
                               me->nSwitchThr =5;
                               AverCPS = me->afCPSBuf[FIRST_CPS_MEASURE_TIME- 1];
               
                               me->byVariWin = 2;
                               memset((void *)me->fLowDRCpsBuf, 0, LOW_DOSE_RATE_MODE_CPS_FITERBUF_SZIE * sizeof(float))
             -;
                               me->iLowDRCPSBufIdx=0;
                               memset((void *)me->fLowDRFiterBuf, 0, sizeof(me->fLowDRFiterBuf)/ sizeof(me->fLowDRFiterB
             -uf[0]));                       
                               me->iLowDRFiterBufIdx = 0;
                               
                               me->fLowDRLastCnt = me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1];  
                               
                               me->nLowCPS = 0;
                               me->nHighCSP = 0;
                               
               
                               
                           }
                           else
                           {
               
               
                            if(DoubtCnt >= 5)
                            {
                               
                                DoubtCnt = 0;
                                me->byDoseRateMode = HIGH_DOSE_RATE_MODE;
               
                       #if 1                   
                                SumCPS = 0; 
                                for (i = 0; i < 10; i++) 
                                {
                                     SumCPS += me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 10 + i];
                                }
                                AverCPS = SumCPS / i;
                                
                                me->byLowDRCPSBufThre  = 5;
                                me->nSwitchThr = 2;
                       #else
                                if (me->afCPSBuf[FIRST_CPS_MEASURE_TIME- 1] >= MIDDLE_DOSE_RATE_THRE)
                                {
                                    me->byLowDRCPSBufThre = 1;
                                    me->nSwitchThr =5;
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 8   

                                    AverCPS = me->afCPSBuf[FIRST_CPS_MEASURE_TIME- 1];
                                }
                                else
                                {
                                    SumCPS = 0; 
                                    for (i = 0; i < 1; i++)  // 原来 i < 5
                                    {
                                         SumCPS += me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1 + i];
                                    }
                                    AverCPS = SumCPS / i;
               
                                    me->byLowDRCPSBufThre  = 5;
                                    me->nSwitchThr = 2;
                                }
               
                       #endif
                                     
                                if (me->byDoseRateMode == HIGH_DOSE_RATE_MODE)
                                {
                                    me->byVariWin = 1;
                                    memset((void *)me->fLowDRCpsBuf, 0, LOW_DOSE_RATE_MODE_CPS_FITERBUF_SZIE * sizeof(fl
             -oat));
                                    me->iLowDRCPSBufIdx=0;
                                    memset((void *)me->fLowDRFiterBuf, 0, sizeof(me->fLowDRFiterBuf)/ sizeof(me->fLowDRF
             -iterBuf[0]));                       
                                    me->iLowDRFiterBufIdx = 0;
                                    
                                    me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1] = AverCPS;
                                    me->fLowDRLastCnt = me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1];  
                                    
                                    me->nLowCPS = 0;
                                    me->nHighCSP = 0;
                                   // me->nSwitchThr = 2;
                                   ldtohdidx = 0;
                                }    
                                     
                             }
                           }
                           
                        }
                        else if (me->byDoseRateMode == HIGH_DOSE_RATE_MODE)
                        {
               
                              
                              if (me->cpsDoseCount < LOW_CPS_THRE && me->byLowDRCPSBufThre == 5)
                              {
                                   me->nHighCSP = 0;
                                   if (++me->nLowCPS >= 3);
                                   {
                                        me->nSwitchThr = 4;
                                        me->nLowCPS = 0;
                                   }
                                  
                              }
                              else if (me->cpsDoseCount >= LOW_CPS_THRE  && me->byLowDRCPSBufThre == 5)
                              {   
                                  me->nLowCPS = 0;
                                  if (++me->nHighCSP >= 3)
                                  {
                                      me->nSwitchThr = 2;
                                      me->nHighCSP = 0;
                                  }
                                  
                              }
                              else
                              {
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 9   

                                   me->nLowCPS  = 0;
                                   me->nHighCSP = 0;
                              }
               
                              
                              if (me->cpsDoseCount < 1)
                              {
                              
                                   if(++me->iGotoLowDRCnt >= 15)
                                   {
                                      /* 连续6秒CPS < 1 回到低剂量(每秒CPS < 1)先快速回到本地。把缓冲区清0*/
                                       memset((void *)me->afCPSBuf, 0, sizeof(me->afCPSBuf));
                                       me->byDoseRateMode = LOW_DOSE_RATE_MODE;  
                                       DoubtCnt = 0;
                                       //bFind = 0;
                                       me->iGotoLowDRCnt  = 0;
                                       me->idxFilterCPS = 0;
                                       me->bSwitchFlag = 1;                        
                                       me->byVariWin =120;
               
                                   
                                   }
                               
                                 
                              }
                              else
                              {
                                  me->iGotoLowDRCnt = 0;
                                  me->bSwitchFlag = 0;
                              }
               
               
                              if (me->bSwitchFlag == 0)
                              {
                                     
                                    if (me->byLowDRCPSBufThre == 1)
                                    {
               
                                        AverCPS = me->cpsDoseCount;
                                        memcpy((void *)me->afCPSBuf, (void *)(&me->afCPSBuf[1]), (FIRST_CPS_MEASURE_TIME
             - - 1) * sizeof me->afCPSBuf[0]);
                                        me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1] = AverCPS;                           
                                        if (me->byVariWin < LOW_DOSE_RATE_MODE_MAX_WIN)
                                        {
                                            me->byVariWin++;
                                        }
                                        
                                       // me->fLowDRLastCnt = RawCPS;
               
                                        if (AverCPS > (me->fLowDRLastCnt + me->fLowDRLastCnt * SWITCH_THR))
                                        {                            
                                            if (me->bLowDRFlage == 1)
                                            {
                                                me->iLowDRFiterBufIdx = 0;
                                            }
                                            me->bLowDRFlage = 2;
                                            me->fLowDRFiterBuf[me->iLowDRFiterBufIdx] = AverCPS;
                                            me->iLowDRFiterBufIdx++;   
                                        }
                                        else if (AverCPS < (me->fLowDRLastCnt - me->fLowDRLastCnt * SWITCH_THR))
                                        {
                                             if (me->bLowDRFlage == 2)
                                             {
                                                  me->iLowDRFiterBufIdx = 0;
                                             }
                                             me->bLowDRFlage = 1;
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 10  

                                             me->fLowDRFiterBuf[me->iLowDRFiterBufIdx] = AverCPS;
                                             me->iLowDRFiterBufIdx++;
                                        }
                                        else 
                                        {
                                             me->iLowDRFiterBufIdx = 0;
                                             me->bLowDRFlage = 0;
                                        }
               
               
                                       if (me->iLowDRFiterBufIdx == me->nSwitchThr)
                                       {
                                           // printf("siwtch:%.3f,%.3f,%.3f\n", me->fLowDRLastCnt,me->afCPSBuf[FIRST_CPS
             -_MEASURE_TIME - 1],AverCPS);
                                           
                                           SumCPS = 0;
                                           for(i = 0; i <  me->nSwitchThr ; i++)
                                           {
                                               SumCPS += me->fLowDRFiterBuf[i];
                                           }
                                           AverCPS = SumCPS / i;
               
                                           if (AverCPS < MIDDLE_DOSE_RATE_THRE)
                                           {
                                               me->byLowDRCPSBufThre = 5; // switch low dose
               
                                               me->byVariWin = 1;
                                               
                                               memset((void *)me->fLowDRFiterBuf, 0, sizeof(me->fLowDRFiterBuf)/ sizeof(
             -me->fLowDRFiterBuf[0]));                       
                                               me->iLowDRFiterBufIdx = 0;
               
                                               memset((void *)me->fLowDRCpsBuf, 0, LOW_DOSE_RATE_MODE_CPS_FITERBUF_SZIE 
             -* sizeof(float));
                                               me->iLowDRCPSBufIdx=0;
                                               
                                               me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1] = AverCPS;
                                               me->fLowDRLastCnt = me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1];  
                                               
                                               me->nLowCPS = 0;
                                               me->nHighCSP = 0;
                                               ldtohdidx =0;
                                               
                                               
                                           }
                                           else
                                           {
                                               me->byVariWin = 5;                                
                  
                                               memcpy((void *)&me->afCPSBuf[FIRST_CPS_MEASURE_TIME - me->nSwitchThr], &m
             -e->fLowDRFiterBuf[0], sizeof(me->fLowDRFiterBuf[0]) * me->nSwitchThr);
                                               me->fLowDRLastCnt     = me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1];
                                               memset((void *)me->fLowDRFiterBuf, 0, sizeof (me->fLowDRFiterBuf));
                                               me->iLowDRFiterBufIdx = 0;
                                               me->bLowDRFlage = 0;
                                           }
                                       
                                        }
                                        else
                                        {
                                             if(me->iLowDRFiterBufIdx == 0)
                                             {
                                                 fTmp = AverCPS;
                                                 memcpy((void *)me->afCPSBuf, (void *)(&me->afCPSBuf[1]), (FIRST_CPS_MEA
             -SURE_TIME - 1) * sizeof me->afCPSBuf[0]);
                                                 me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1] = fTmp;  
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 11  

                                                 me->fLowDRLastCnt = fTmp;
                                             
                                             }
                                        }
               
                                            
                                    }
                                    else  // me->byLowDRCPSBufThre == 5
                                    {
                                        me->fLowDRCpsBuf[me->iLowDRCPSBufIdx] = me->cpsDoseCount;
               
                                        if (me->cpsDoseCount < MIDDLE_DOSE_RATE_THRE)
                                        {
                                           ldtohdidx = 0;
                                        }
               
                                        else
                                        {
                                           LDtoHDBuf[ldtohdidx++] = me->cpsDoseCount;
                                        }
               
                                        if (ldtohdidx >=3)
                                        {
                                           
                                             me->byLowDRCPSBufThre = 1; //switch hig dose                               
             -                                          
                                             me->byVariWin = 3;
                                             memcpy((void *)&me->afCPSBuf[FIRST_CPS_MEASURE_TIME - (sizeof(LDtoHDBuf) / 
             -sizeof(LDtoHDBuf[0]))], (void *)LDtoHDBuf, (sizeof(LDtoHDBuf) / sizeof(LDtoHDBuf[0])));
                                             
                                             me->fLowDRLastCnt = me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1];  
                                             memset((void *)me->fLowDRFiterBuf, 0, sizeof(me->fLowDRFiterBuf)/ sizeof(me
             -->fLowDRFiterBuf[0]));                       
                                             me->iLowDRFiterBufIdx = 0;
                                             me->nLowCPS = 0;
                                             me->nHighCSP = 0;
                                             ldtohdidx = 0;
                                             
                                        }
                                        else
                                        {
                
                                           if (++me->iLowDRCPSBufIdx >=  me->byLowDRCPSBufThre )
                                            {         
                                                 if (me->byVariWin < LOW_DOSE_RATE_MODE_MAX_WIN)
                                                 {
                                                     me->byVariWin++;
                                                 }
                                                 SumCPS = 0;
                                                 for(i = 0; i <  me->byLowDRCPSBufThre ; i++)
                                                 {
                                                     SumCPS += me->fLowDRCpsBuf[i];
                                                 }
                                                 AverCPS = SumCPS / me->byLowDRCPSBufThre;
                                                 
                                               //  printf("five aver:%.3f\n",AverCPS);
                                                 
                                                 if (AverCPS > (me->fLowDRLastCnt + me->fLowDRLastCnt * SWITCH_THR))
                                                 {
                                                      if (me->bLowDRFlage == 1)
                                                      {
                                                          me->iLowDRFiterBufIdx = 0;
                                                      }
                                                      me->bLowDRFlage = 2;
                                                      me->fLowDRFiterBuf[me->iLowDRFiterBufIdx] = AverCPS;
                                                      me->iLowDRFiterBufIdx++;
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 12  

                                                 }
                                                 else if (AverCPS < (me->fLowDRLastCnt - me->fLowDRLastCnt * SWITCH_THR)
             -)
                                                 {
                                                      if (me->bLowDRFlage == 2)
                                                      {
                                                           me->iLowDRFiterBufIdx = 0;
                                                      }
                                                      me->bLowDRFlage = 1;
                                                      me->fLowDRFiterBuf[me->iLowDRFiterBufIdx] = AverCPS;
                                                      me->iLowDRFiterBufIdx++;
                                                 }
                                                 else 
                                                 {
                                                      me->iLowDRFiterBufIdx = 0;
                                                      me->bLowDRFlage = 0;
                                                 }
                                                 
                                                     
                                                 if (me->iLowDRFiterBufIdx == me->nSwitchThr )
                                                 {
                                                    //  printf("siwtch:%.3f,%.3f,%.3f\n", me->fLowDRLastCnt,me->afCPSBuf
             -[FIRST_CPS_MEASURE_TIME - 1],AverCPS);
                  
                                                      AverCPS =  (me->fLowDRFiterBuf[0] + me->fLowDRFiterBuf[1]) / 2;
                                                      if (AverCPS >= MIDDLE_DOSE_RATE_THRE)
                                                      {
                                                           me->byLowDRCPSBufThre = 1; //switch hig dose                 
             -                                                        
                                                           me->byVariWin = 2;
                                                           memcpy((void *)&me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 2], (vo
             -id *)me->fLowDRFiterBuf, sizeof(me->fLowDRFiterBuf[0]) * 2);
                  
                                                           me->fLowDRLastCnt = me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1];
             -  
                  
                                                           memset((void *)me->fLowDRFiterBuf, 0, sizeof(me->fLowDRFiterB
             -uf)/ sizeof(me->fLowDRFiterBuf[0]));                       
                                                           me->iLowDRFiterBufIdx = 0;
                                                           me->nLowCPS = 0;
                                                           me->nHighCSP = 0;
                                                             
                                                           
                                                      }
                                                      else
                                                      {
                                                           me->byVariWin = 1;
                                                              
                                                           me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1] = (me->fLowDRFiterBu
             -f[0] + me->fLowDRFiterBuf[1]) / 2;            
                                                           me->fLowDRLastCnt =  me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1]
             -;
                                                              
                                                           me->fLowDRFiterBuf[0] = 0;
                                                           me->fLowDRFiterBuf[1] = 0;
                                                           me->iLowDRFiterBufIdx = 0;
                                                              
                                                           me->bLowDRFlage = 0;
                                                      }
                                         
                                                  }
                                                  else
                                                  {
                                                       if(me->iLowDRFiterBufIdx == 0);
                                                       {
                                                           fTmp = AverCPS;
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 13  

                                                           memcpy((void *)me->afCPSBuf, (void *)(&me->afCPSBuf[1]), (FIR
             -ST_CPS_MEASURE_TIME - 1) * sizeof me->afCPSBuf[0]);
                                                           me->afCPSBuf[FIRST_CPS_MEASURE_TIME - 1] = fTmp;  
                                                           me->fLowDRLastCnt = fTmp;
                                                       
                                                       }
                                                  }
                                                 
                                                 me->iLowDRCPSBufIdx = 0;  
                                            }// if (++me->iLowDRCPSBufIdx >= 5)
                                       }//if (ldtohdidx >=3)
                                    }
                    
                             } 
                         }
                                
                      /* 计算平均CPS */   
                      {
                        /*晚上发个老毕的*/
                        
                        if (me->byDoseRateMode == HIGH_DOSE_RATE_MODE)
                        {   
                            
                            SumCPS = 0;
                            Max = 0;
                          //  printf("buf win size:%d\n",me->byVariWin);
                            
                            for(i = 0; i< me->byVariWin;i++)
                            {
                                if (me->afCPSBuf[FIRST_CPS_MEASURE_TIME - me->byVariWin + i] > Max)
                                {
                                    Max = me->afCPSBuf[FIRST_CPS_MEASURE_TIME - me->byVariWin  + i];
                                }                     
                                SumCPS +=me->afCPSBuf[FIRST_CPS_MEASURE_TIME - me->byVariWin + i];
                                
                            }
                          //  printf("\n");
               
               
                           if (me->nSwitchThr == 4 && me->byVariWin >= LOW_DOSE_RATE_MODE_MAX_WIN)
                           {
                                iMinCnt = 0;
                                for(i = 0; i< LOW_DOSE_RATE_MODE_MAX_WIN; i++)
                                {
                                     if (me->afCPSBuf[FIRST_CPS_MEASURE_TIME - LOW_DOSE_RATE_MODE_MAX_WIN + i] == Max)
                                     {
                                        iMinCnt++;
                                     }
                                }
                                if (iMinCnt <= 3)//如果最大计数有3个以下，这个最大计数就有可能是一个异常值，所以需要去掉
             - 2016.3.25
                                {
                                    SumCPS = SumCPS - iMinCnt * Max;
                                    fAverCPS = SumCPS / (LOW_DOSE_RATE_MODE_MAX_WIN - iMinCnt);
                                } 
                                else
                                {
                                    fAverCPS = SumCPS / LOW_DOSE_RATE_MODE_MAX_WIN ;                        
                                }
               
                               
                                
                           }
                           else
                           {
                                if (me->byVariWin >= LOW_DOSE_RATE_MODE_MAX_WIN)
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 14  

                                {
                                      fAverCPS = SumCPS / LOW_DOSE_RATE_MODE_MAX_WIN;
                                      fAverCPS = (SumCPS - Max + fAverCPS) /LOW_DOSE_RATE_MODE_MAX_WIN;
                                }
                                else
                                {
                                     if (me->byVariWin > 0)
                                     {       
                                         fAverCPS = SumCPS / me->byVariWin;
                                     }
                                     else
                                     {
                                         fAverCPS = 0;
                                     }
                
                                }
                           }
               
               
                           #if 1
               
                               if(me->iLowDRCPSBufIdx > 0)
                               {
                                   int s;
                                   s =rand()% 9;
                                   if ( s > 4)
                                   {
                                       fAverCPS = fAverCPS + s/1000.0;
                                   }
                                   else
                                   {
                                       fAverCPS = fAverCPS - s/1000.0;
                                   }
               
                               }
                           #endif                
                        }
                        else
                        {    
                           
                             SumCPS = 0;
                             for( i = 0; i < me->byVariWin; i++)
                             {
                               
                                SumCPS+= me->afCPSBuf[FIRST_CPS_MEASURE_TIME - me->byVariWin + i];
                             }
                             fAverCPS = SumCPS / i;
               
                        }
                      }
               
                   //fAverCPS = 20.8;
                   
                   me->fDoseRate = QEpdDoseRateCalc();//me->cpsDoseCount/10000.0f;//QEpdDoseRateCalc(me,fAverCPS,0);
                   me->fDoseRate *= me->EpdPara.baseConfig.iScaleFactor;
                   me->fDoseSumx += (me->fDoseRate/3600.0f);
                       
                   me->EpdPara.statusInfo.iLastDoseSum = me->fDoseSumx;
                   
                   if(me->fDoseRate > me->EpdPara.statusInfo.iMaxDoseRate) 
                   {
                       me->EpdPara.statusInfo.iMaxDoseRate = me->fDoseRate;
                   }
               
                   //me->fDoseRate = 10.2;
               
C251 COMPILER V5.60.0,  epd_dose                                                           21/05/24  09:30:57  PAGE 15  

               
                   
               
                   /*me->scaleDoseRate  = QEpdDoseRateCalc(me,fAverCPS,0);
                   me->scaleDoseRate *= me->EpdPara.baseConfig.iScaleFactor;
                   
                   me->scaleSumDose   += (me->scaleDoseRate/3600);//msv/s
                   me->scaleSumDoseCom = me->scaleSumDose*1000;//2012.10.22  μ
                   me->scaleDoseRateCom= me->scaleDoseRate*1000;*/
               
                   
                   //me->fDoseRate = 0x00;//me->EpdPara.baseConfig.iScaleFactor;
                   //me->fDoseSumx = 0x00;//(me->fDoseRate/3600);
                   //me->EpdPara.statusInfo.iMaxDoseRate = me->fDoseRate;//导致数据不准    
                   //me->EpdPara.statusInfo.iLastDoseSum = rand()/1000.0f;//me->fDoseSumx;//导致数据不准
                   #endif    
               }
               
               
               #endif
  903          
  904          #endif
  905          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       261     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        21         12
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       533     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
